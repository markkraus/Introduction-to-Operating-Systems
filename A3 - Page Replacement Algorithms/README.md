Project 3: Virtual Memory Simulator
==========================
(_Based upon Project 3 of Dr. Misurda's CS 1550 course._)

To submit your project code, submit your GitHub Classroom repository to Gradescope. **Only the following files will be used for grading**:

- Your code files (in C, C++, Java, Python, or Perl) for the virtual memory simulator
- `p3-writeup.md` (the writeup in [GitHub Markdown](https://guides.github.com/features/mastering-markdown/))

Don't forget to name your writeup `p3-writeup.md`.

- Due date: Friday, 4/5/2024 at 11:59 pm EST
- Late due date: Sunday, 4/7/2024 at 11:59 pm EST

---


Project Overview
----------------

In class, we discussed various page replacement algorithms. We also discussed local and global page replacement policies. Each process is allocated a certain number of physical memory frames in local page replacement. When a page is to be evicted, the victim page is selected among the pages of the same process. In this project, you will simulate the **Least Frequently Used (LFU)** and a **modification of Optimal (OPT)** page replacement algorithms. Your program will read *traces* of memory references generated by two processes while running on a 32-bit system.  Each process has its frames (a percentage of the total physical frames). While simulating the algorithm, you will collect statistics about its performance, such as the number of page faults that occur and the number of dirty frames that had to be written back to disk. When you finish your program, you will write up your results and provide one or more graphs that compare the performance of the two algorithms. The page size, the number of frames, and the memory split between the two processes are command-line arguments of your program.

_You may write your program in C/C++, Java, Perl, or Python if it runs on thoth.cs.pitt.edu with the “./vsim” command specified below._


Project Details
---------------

Your virtual memory simulator, called `vmsim`, takes the following command-line arguments:
```shell
./vmsim -a <opt*|lfu> –n <numframes> -p <pagesize in KB> -s <memory split> <tracefile>
```
The **Least Frequently Used (LFU)** algorithm evicts the page with the smallest (among pages of the process in physical memory) number of past accesses since the page was last loaded into memory. If two or more pages have the same number of accesses, the least recently accessed page among them is selected.

The __modified Optimal (OPT*)__ algorithm evicts the page with the smallest (among pages of the process in physical memory) number of future accesses. If two or more pages have the same number of future accesses, the least recently accessed page is selected.

The memory split between the two processes is provided in the form a:b, where a and b are positive integers > 0, representing the ratios of each process's memory allocation. For example, a 1:2 split means that the second process gets twice as many frames as the first process (i.e., the first process gets one-third and the second two-thirds). The sum of a and b evenly divides the total number of frames.

The program/simulator will run through the memory references of the trace file and decide the action taken for each address (memory hit, page fault with no eviction, page fault and evict a clean page, page fault and evict a dirty page).
When the trace is over (that is, after dealing with all the memory references for both simulated processes), `vmsim` prints out summary statistics **in the following format (as you know, Gradescope grading requires very strict formatting)**:
```
Algorithm: LFU
Number of frames: 8
Page size: 8 KB
Total memory accesses: %d
Total page faults: %d
Total writes to disk: %d
```
```
Algorithm: OPT*
Number of frames: 8
Page size: 8 KB
Total memory accesses: %d
Total page faults: %d
Total writes to disk: %d
```

Your simulator takes a command-line argument (among others) that specifies the trace file. The trace file will specify all the data memory accesses done by the two processes. Each line in the trace file will specify a new memory reference and the process that made the access. Each line in the trace has the following three fields:

- Access Type: A single character indicating whether the access is a load/read ('l') or a store/write ('s'). The ‘s’ access type sets the dirty bit to true. 
- Address: A 32-bit integer (in unsigned hexadecimal format) specifying the memory address being accessed. For example, `0xff32e100` specifies that memory address `4281524480` (in decimal) is accessed.
- Process Number: Either 0 or 1, representing which of the two processes made the memory access.
- 
Single spaces separate fields on the same line. An example trace lines look like this:
```
l 0x012ff200 0
s 0xfe7fefc8 1
```
If you are writing in C/C++, you may parse each line with the following code:
```c
unsigned int address;
char mode;
int process;

fscanf(file, "%c %x %d", &mode, &addr, &process);
```

We are providing three sample memory traces. The traces are available within this repository and at `/u/OSLab/original/` in the files `1.trace.gz`, `2.trace.gz`, and `3.trace.gz`. We will use more trace files to test your program when grading. Each trace is `gzip` compressed, so you will have to copy each trace to your directory under `/u/OSLab/USERNAME/` and then decompress it like this:
```
gunzip 1.trace.gz
```

Important Notes
--------------------
1.	When a dirty page is evicted, it has to be written to disk.
2.	If you are using Python, name your file `vmsim` and add the following shebang line at the beginning of the file: `#!/usr/bin/env python`
3. Implementing OPT* in a naïve fashion will lead to unacceptable performance. You should use a hash table to implement OPT*.
5. If you are using Java, the autograder has a script that detects your main class and runs it as `./vmsim ...`; you don't have to worry about that.
6. At the end of the simulation, don't count the remaining dirty pages as disk writes.


Write Up
-------------
Select any trace file and show (using one or more graphs) in a document the number of page faults for the following seven memory splits: 1:1, 1:3, 3:1, 3:5, 5:3, 7:9, 9:7 under each of the following memory configurations:

-	16 frames and 4 KB pages
-	1024 frames and 4 KB pages
-	16 frames and 4 MB pages
-	1024 frames and 4 MB pages

For example, you can have a graph for each memory configuration and 14 curves within each graph (two per memory split: one for OPT* and one for LFU). Other more (or less) creative ideas for plotting the comparisons are welcome.

Extra Credit (10 points)
-------------------------
You can do the following tasks for extra credit.

Read 64-bit memory trace files, in which the memory addresses are 64-bit integers (in unsigned hexadecimal format). For example, `0x7894ff32e100` specifies that memory address `132581332017408` (in decimal) is accessed.

If you are writing in C/C++, you may parse each line with the following code:
```c
unsigned long int address;
char mode;
int process;

fscanf(file, "%c %lx %d", &mode, &addr, &process);
```
We are providing three sample 64-bit memory traces. The traces  are available within this repository and at `/u/OSLab/original/` in the files `1-64.trace.gz`, `2-64.trace.gz`, and `3-64.trace.gz`. We will use more trace files to test your program when grading.


File Backups
------------

The `/u/OSLab/` partition is **not** part of AFS space. Thus, any files you modify under that folder are not backed up. If a catastrophic disk fails, your work will be irrecoverably lost. As such, we recommend that you:

**Commit and push all the files you change to your GitHub repository frequently!**

**BE FOREWARNED:** Loss of work not backed up is not grounds for an extension.


Submission
----------

You need to submit onto Gradescope:
-	Your well-commented program’s source
-	The writeup (named `p3-writeup.md`) detailing the results of your simulation as described above

**The autograder will run your program as:**
```shell
./vmsim -a <opt*|lfu> –n <numframes> -p <pagesize in KB> -s <memory split> <tracefile>
```


Grading rubric
--------------

|Item|Grade|
|----|-----|
|Test cases on the autograder|80%|
|Comments and style|10%|
|Report|10%|
|Extra Credit|10%|


**If the autograder score is below 40 points (out of 80), a partial grade will be assigned using manual grading of your code. The maximum points that you can get in this manual grading is 50 points. Again, non-compiling code gets **zero** points.**

Please note that the score that you get from the autograder is not your final score. We still do manual grading. We may discover bugs and mistakes that were not caught by the test scripts and take penalty points off. Please use the autograder (or the local test harness `make test`) only as a tool to get immediate feedback and discover bugs in your program. Please note that certain bugs (e.g., deadlocks) in your program may or may not manifest themselves when the test cases are run on your program. It may be the case that the same exact code fails in some tests then the same code passes the same tests when resubmitted. The fact that a test once fails should make you debug your code, not simply resubmit and hope that the situation that caused the bug won't happen the next time around.
